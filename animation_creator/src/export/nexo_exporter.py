"""
Nexo ResourcePack Exporter - Generate Nexo-compatible resourcepack
"""

import json
from pathlib import Path
from typing import List, Dict, Any
from PIL import Image
from core.frame_manager import FrameManager, Frame

class NexoExporter:
    """Exports animation as Nexo-compatible resourcepack."""
    
    def __init__(self):
        self.pack_format = 15  # Minecraft 1.20+
        self.default_size = (256, 256)
        
    def export_resourcepack(self, frames: List[Frame], output_folder: str, 
                          animation_name: str = "custom_animation",
                          pack_name: str = "Loadscreen Animation Pack"):
        """Export complete Nexo resourcepack."""
        if not frames:
            raise ValueError("No frames to export")
            
        output_path = Path(output_folder)
        output_path.mkdir(parents=True, exist_ok=True)
        
        # Create resourcepack structure
        self._create_pack_structure(output_path, pack_name)
        
        # Export animation frames
        self._export_animation_frames(frames, output_path, animation_name)
        
        # Create font configuration
        self._create_font_config(output_path, animation_name, len(frames))
        
        # Create Nexo configuration
        self._create_nexo_config(output_path, animation_name, len(frames))
        
        return str(output_path)
        
    def _create_pack_structure(self, base_path: Path, pack_name: str):
        """Create basic resourcepack structure."""
        # Create directories
        (base_path / "assets" / "nexo" / "textures" / "gui").mkdir(parents=True, exist_ok=True)
        (base_path / "assets" / "nexo" / "font").mkdir(parents=True, exist_ok=True)
        (base_path / "assets" / "minecraft" / "font").mkdir(parents=True, exist_ok=True)
        
        # Create pack.mcmeta
        pack_meta = {
            "pack": {
                "pack_format": self.pack_format,
                "description": f"§a{pack_name}\\n§7Generated by Loadscreens Animation Creator"
            }
        }
        
        with open(base_path / "pack.mcmeta", 'w', encoding='utf-8') as f:
            json.dump(pack_meta, f, indent=2)
            
    def _export_animation_frames(self, frames: List[Frame], base_path: Path, animation_name: str):
        """Export animation frames to resourcepack."""
        textures_path = base_path / "assets" / "nexo" / "textures" / "gui" / animation_name
        textures_path.mkdir(parents=True, exist_ok=True)
        
        exported_files = []
        
        for i, frame in enumerate(frames):
            # Render frame
            frame_image = frame.render()
            
            # Ensure image is 256x256
            if frame_image.size != self.default_size:
                frame_image = frame_image.resize(self.default_size, Image.Resampling.LANCZOS)
                
            # Save frame
            filename = f"frame_{i+1:03d}.png"
            file_path = textures_path / filename
            frame_image.save(file_path, "PNG")
            exported_files.append(filename)
            
        return exported_files
        
    def _create_font_config(self, base_path: Path, animation_name: str, frame_count: int):
        """Create font configuration for animation frames."""
        # Generate unicode codepoints for frames
        start_codepoint = 0xE000  # Private Use Area
        
        providers = []
        
        # Add each frame as a glyph
        for i in range(frame_count):
            codepoint = start_codepoint + i
            providers.append({
                "type": "bitmap",
                "file": f"nexo:gui/{animation_name}/frame_{i+1:03d}.png",
                "ascent": 8,
                "height": 16,
                "chars": [chr(codepoint)]
            })
            
        # Create font configuration
        font_config = {
            "providers": providers
        }
        
        # Save to both nexo and minecraft font folders
        font_paths = [
            base_path / "assets" / "nexo" / "font" / f"{animation_name}.json",
            base_path / "assets" / "minecraft" / "font" / f"{animation_name}.json"
        ]
        
        for font_path in font_paths:
            with open(font_path, 'w', encoding='utf-8') as f:
                json.dump(font_config, f, indent=2)
                
    def _create_nexo_config(self, base_path: Path, animation_name: str, frame_count: int):
        """Create Nexo-specific configuration files."""
        nexo_path = base_path / "nexo"
        nexo_path.mkdir(exist_ok=True)
        
        # Create items configuration for Nexo
        start_codepoint = 0xE000
        
        # Generate character sequence for animation
        animation_chars = ""
        for i in range(frame_count):
            animation_chars += chr(start_codepoint + i)
            
        items_config = {
            animation_name: {
                "displayname": f"&a{animation_name.replace('_', ' ').title()}",
                "material": "PAPER",
                "Components": {
                    "custom_model_data": 1001 + hash(animation_name) % 1000,  # Generate unique CMD
                    "font": f"nexo:{animation_name}",
                    "animation_frames": animation_chars,
                    "frame_count": frame_count
                },
                "ItemMeta": {
                    "lore": [
                        "&7Animation created with",
                        "&bLoadscreens Animation Creator",
                        f"&8{frame_count} frames"
                    ],
                    "hide_enchants": True,
                    "hide_attributes": True
                }
            }
        }
        
        with open(nexo_path / "items.yml", 'w', encoding='utf-8') as f:
            # Write as YAML
            import yaml
            yaml.dump(items_config, f, default_flow_style=False, indent=2)
            
        # Create glyph configuration
        glyph_config = {
            "glyphs": {}
        }
        
        for i in range(frame_count):
            codepoint = start_codepoint + i
            glyph_config["glyphs"][f"{animation_name}_frame_{i+1}"] = {
                "character": chr(codepoint),
                "font": f"nexo:{animation_name}",
                "texture": f"nexo:gui/{animation_name}/frame_{i+1:03d}.png",
                "ascent": 8,
                "height": 16
            }
            
        with open(nexo_path / "glyphs.yml", 'w', encoding='utf-8') as f:
            import yaml
            yaml.dump(glyph_config, f, default_flow_style=False, indent=2)
            
    def create_installation_guide(self, output_folder: str, animation_name: str):
        """Create installation guide for the resourcepack."""
        guide_content = f"""# {animation_name.replace('_', ' ').title()} Installation Guide

## ResourcePack Installation

1. **Copy ResourcePack**
   - Copy the generated resourcepack folder to your server's world folder
   - Or upload to your server's resourcepack hosting

2. **Nexo Integration**
   - If using Nexo, copy the contents of the `nexo/` folder to your Nexo plugin configuration
   - Reload Nexo configuration: `/nexo reload`

3. **Loadscreens Plugin Configuration**
   - Copy the generated YAML configuration to your Loadscreens plugin config
   - Update frame paths to match your resourcepack structure
   - Reload Loadscreens: `/loadscreen reload`

## Usage

### In Loadscreens Plugin

Add to your `config.yml`:

```yaml
loadscreen_types:
  {animation_name}:
    enabled: true
    frames:
      - "frame_001.png"
      - "frame_002.png"
      # ... add all frame files
    frame_interval: 10
    duration: 100
    show_on_join: true
```

### With Nexo

The animation is available as item `{animation_name}` with font glyphs for each frame.

### Manual Frame Usage

Individual frames can be used directly:
- Frame files: `assets/nexo/textures/gui/{animation_name}/frame_XXX.png`
- Font glyphs: Use the generated unicode characters

## Troubleshooting

- **Frames not showing**: Check file paths in configuration
- **ResourcePack not loading**: Verify pack.mcmeta format version
- **Nexo items missing**: Ensure Nexo configuration is properly loaded

## Support

For support with the Loadscreens plugin, visit:
- GitHub: https://github.com/Anonventions/Loadscreens
- Discord: https://discord.gg/SG8jvb9WU5

---
Generated by Loadscreens Animation Creator
"""
        
        guide_path = Path(output_folder) / "INSTALLATION.md"
        with open(guide_path, 'w', encoding='utf-8') as f:
            f.write(guide_content)
            
        return str(guide_path)
        
    def export_mcmeta_animation(self, frames: List[Frame], output_path: str, 
                              frame_time: int = 2, interpolate: bool = False):
        """Export as Minecraft .mcmeta animated texture."""
        if not frames:
            raise ValueError("No frames to export")
            
        # Create animation texture (vertical strip)
        frame_width, frame_height = self.default_size
        animation_height = frame_height * len(frames)
        
        animation_texture = Image.new('RGBA', (frame_width, animation_height))
        
        # Compose frames vertically
        for i, frame in enumerate(frames):
            frame_image = frame.render()
            
            if frame_image.size != self.default_size:
                frame_image = frame_image.resize(self.default_size, Image.Resampling.LANCZOS)
                
            y_offset = i * frame_height
            animation_texture.paste(frame_image, (0, y_offset))
            
        # Save texture
        texture_path = Path(output_path)
        animation_texture.save(texture_path.with_suffix('.png'), "PNG")
        
        # Create .mcmeta file
        mcmeta = {
            "animation": {
                "frametime": frame_time,
                "interpolate": interpolate,
                "frames": list(range(len(frames)))
            }
        }
        
        mcmeta_path = texture_path.with_suffix('.png.mcmeta')
        with open(mcmeta_path, 'w', encoding='utf-8') as f:
            json.dump(mcmeta, f, indent=2)
            
        return str(texture_path.with_suffix('.png')), str(mcmeta_path)